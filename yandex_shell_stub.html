<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>PvZ Portable</title>
<style>
html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#000; }
/* Canvas is positioned/sized entirely by fitCanvas() below */
#canvas { display:block; position:absolute; }
#loading { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
  color:#fff; font:20px sans-serif; text-align:center; z-index:10; }
#loading .bar { width:300px; height:20px; border:2px solid #555; margin:10px auto; }
#loading .fill { height:100%; background:#4a0; width:0%; transition:width .2s; }
</style>
</head>
<body>
<div id="loading">
  <div>Loading PvZ Portable...</div>
  <div class="bar"><div class="fill" id="progress"></div></div>
  <div id="status">Initializing...</div>
</div>
<canvas id="canvas" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>

<script>
/**
 * fitCanvas() — Enforces strict 4:3 aspect ratio.
 *
 * Calculates the largest 4∶3 rectangle that fits inside the browser
 * viewport, centres it, and applies the size via style.setProperty
 * with !important so SDL's inline-style overrides are ignored.
 *
 * Called once on load and on every window resize / orientation change.
 */
function fitCanvas() {
  var vw = window.innerWidth, vh = window.innerHeight;
  var cw, ch;
  if (vw / vh > 4 / 3) {
    ch = vh; cw = Math.round(vh * 4 / 3);
  } else {
    cw = vw; ch = Math.round(vw * 3 / 4);
  }
  var c = document.getElementById('canvas');
  if (!c) return;
  c.style.setProperty('width',  cw + 'px', 'important');
  c.style.setProperty('height', ch + 'px', 'important');
  c.style.setProperty('left', Math.round((vw - cw) / 2) + 'px', 'important');
  c.style.setProperty('top',  Math.round((vh - ch) / 2) + 'px', 'important');
}
fitCanvas();
window.addEventListener('resize', fitCanvas);

window.YG = {
  sdk: null,
  player: null,
  ready: false,

  init: function() {
    console.log('[YG Stub] SDK init (stub)');
    document.getElementById('status').textContent = 'Loading game...';
    return Promise.resolve();
  },

  signalReady: function() {
    console.log('[YG Stub] LoadingAPI.ready()');
    window.YG.ready = true;
    var el = document.getElementById('loading');
    if (el) el.style.display = 'none';
  },

  showInterstitial: function() {
    console.log('[YG Stub] showInterstitial (no-op)');
  },

  saveData: function(key, base64data) {
    try {
      localStorage.setItem('yg_save_' + key, base64data);
      console.log('[YG Stub] saveData:', key, '(' + base64data.length + ' chars)');
      return Promise.resolve(true);
    } catch(e) { return Promise.resolve(false); }
  },

  loadData: function(key) {
    var val = localStorage.getItem('yg_save_' + key);
    console.log('[YG Stub] loadData:', key, val ? '(' + val.length + ' chars)' : '(null)');
    return Promise.resolve(val);
  },

  deleteData: function(key) {
    localStorage.removeItem('yg_save_' + key);
    console.log('[YG Stub] deleteData:', key);
    return Promise.resolve(true);
  }
};

document.addEventListener('visibilitychange', function() {
  if (document.hidden) {
    if (typeof Module !== 'undefined' && Module._pvz_yg_on_visibility_hidden)
      Module._pvz_yg_on_visibility_hidden();
  } else {
    if (typeof Module !== 'undefined' && Module._pvz_yg_on_visibility_visible)
      Module._pvz_yg_on_visibility_visible();
  }
});

var Module = {
  canvas: (function() { return document.getElementById('canvas'); })(),
  setStatus: function(text) {
    var el = document.getElementById('status');
    if (el) el.textContent = text;
    var m = text.match(/(\d+)\/(\d+)/);
    if (m) {
      var pct = Math.round(100 * parseInt(m[1]) / parseInt(m[2]));
      var fill = document.getElementById('progress');
      if (fill) fill.style.width = pct + '%';
    }
  },
  onRuntimeInitialized: function() {
    document.getElementById('status').textContent = 'Loading assets...';
  }
};
window.onerror = function(e) { Module.setStatus('Error: ' + e); };
</script>
{{{ SCRIPT }}}
</body>
</html>
